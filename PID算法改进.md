连续形式PID:
&emsp;&emsp;&emsp; $out(t)=K_p*error(t)+K_i*\int^t_0error(t)dt+K_d*\frac{derror(t)}{dt}$
离散形式位置式PID:
&emsp;&emsp;&emsp; $out(k)=K_p*error(k)+K_i*\Sigma^k_{j=0}error(j)+K_d*(error(k)-error(k-1))$
离散形式增量式PID:
&emsp;&emsp;&emsp; $\Delta out(k)=K_p*(error(k)-error(k-1))+K_i*error(k)+K_d*(error(k)-2error(k-1)+error(k-2))$

连续形式PID中的t代表时间，是连续的值，表示t这个时刻应输出的out(t)
离散形式PID中的k表示离散的时间刻度，更多的是表示次数，第k次应输出的out(k)
### 积分部分改进
## 积分限幅
**要解决的问题:**如果执行器(舵机/电机)因为卡住、断电、损坏等原因不能消除误差error，则误差积分会无限制加大，最终超出一个正常范围，达到深度饱和状态，此时PID的控制器(主控单片机)会持续输出最大的调控力，即使后续执行器恢复正常，PID控制器在短时间内也会维持最大的调控力(因为error的积分仍然非常大，会让out值直接拉满)，直到误差积分从深度饱和状态退出。这段时间内执行器会一直保持满速运行，容易损坏执行器

**积分限幅实现思路:**对误差积分或积分项输出进行判断，如果幅值超过指定阈值，则进行限制，具体阈值的限制需要观察实际运行时误差积分的最大值
```C
errorInt+=errorNow;
if(errorInt>=ERROR_INT_MAX)
{
    errorInt=ERROR_INT_MAX;
}
else if(errorInt<=ERROR_INT_MIN>)
{
    errorInt=ERROR_INT_MIN;
}
```

## 积分分离
**要解决的问题:**积分项一般作用于调控的后期，用于消除纯p项调节无法消除的稳态误差，调控的前期一般误差较大且不需要积分项作用，如果前期就开始误差积分的积累，则最终达到target时，error为0，p项调控会归零，但误差积分已经累积了一部分调控力，所以肯定会导致超调，这在定位置控制中非常常见，在定速控制中较为少见，因为定速控制中输出值不会归零，积分项累积的调控力会用来抵消摩擦力，保持控制器的速度(二力平衡，没有外力作用时速度保持不变);而定位置控制最终达到目标位置时需要保持位置，而保持这个位置并不需要控制器的作用，out需要归零，而误差积分并不为零，所以导致超调，需要过一段时间才会归零，造成延后
**积分分离实现思路:**对误差大小进行判断，如果误差绝对值小于指定阈值，则加入积分项作用，反之，直接将误差积分清零或者out输出不加入积分项。误差是朝着变小的方向去的，所以是小于阈值时，再开始误差积分累积作用，防止误差积分过早累积，导致最后过大(刹不住车)
```C
if(errorNow<积分分离阈值&&errorNow>-积分分离阈值)
{
    errorInt+=errorNow;
}
else
{
    errorInt=0;
}
```

## 变速积分
**要解决的问题:**如果积分分离的阈值没有设定好，被控对象正好在阈值之外停下，则此时控制器会完全没有积分作用，误差不能消除
**变速积分实现思路:**变速积分是积分分离的扩展，变速积分需要设计一个函数，这个函数值随误差绝对值增大而减小，函数值作为调整系数，用于调整误差积分的速度或积分项作用的强度。也就是说不再使用单一的积分分离，超过阈值归零，小于阈值开始误差积分积累，而是让它的积累强度是一个渐变的阶段。


### 微分部分改进

### 输入输出部分改进